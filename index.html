<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <title>DADOS METEOROLÓGICOS DETALHADOS POR REGIÃO</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="refresh" content="900">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #00796b;
            text-align: center;
        }
        .header-info {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 20px;
        }
        .region-title {
            color: #004d40;
            text-align: center;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 2px solid #004d40;
            padding-bottom: 5px;
        }
        .uf-title {
            color: #00897b;
            text-align: left;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.5em;
        }
        p {
            text-align: center;
            color: #666;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            background-color: #fff;
        }
        thead th {
            background-color: #009688;
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-weight: bold;
            cursor: pointer;
        }
        thead th:hover {
            background-color: #00796b;
        }
        tbody td {
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
        }
        tbody tr:nth-of-type(even) {
            background-color: #f9f9f9;
        }
        tbody tr:hover {
            background-color: #f1f1f1;
        }
        .capital-row {
            font-weight: bold;
            background-color: #bbdefb !important;
        }
        .loading-animation {
            text-align: center;
            margin-top: 50px;
        }
        .loading-animation img {
            width: 50px;
            height: 50px;
        }
        .data-source-info {
            font-size: 0.8em;
            color: #888;
            margin-top: 10px;
            text-align: center;
        }
        .container {
            max-width: 1200px;
            margin: auto;
        }
        .chart-container {
            width: 80%;
            margin: 40px auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        /* Estilos para o Seletor de Data */
        .date-selector-container {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background-color: #e0f2f1;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .date-selector-container label {
            font-weight: bold;
            color: #004d40;
            margin-right: 10px;
        }
        .date-selector-container input[type="date"] {
            padding: 8px;
            border: 1px solid #009688;
            border-radius: 4px;
            font-size: 1em;
            margin-right: 10px;
        }
        .date-selector-container button {
            padding: 8px 15px;
            background-color: #009688;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        .date-selector-container button:hover {
            background-color: #00796b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dados Meteorológicos por Estação e Região</h1>
        <p>Dados de todas as estações do INMET no Brasil.</p>

        <div class="header-info">
            <p id="currentDateTime"></p>
            <p id="lastRefreshTime"></p>
        </div>

        <div class="date-selector-container">
            <label for="date-input">Buscar dados do dia:</label>
            <input type="date" id="date-input">
            <button id="search-button">Buscar</button>
        </div>
        <div class="loading-animation" id="loading">
            <img src="https://i.imgur.com/u7sA5mF.gif" alt="Carregando...">
            <p>Carregando dados, por favor aguarde...</p>
        </div>

        <div id="data-container" style="display: none;">
            <h2 class="region-title">Gráficos de Destaque</h2>
            <div class="chart-container">
                <h3>Top 15 Municípios com Maior Precipitação</h3>
                <canvas id="chart-chuva-total"></canvas>
            </div>
            <div class="chart-container">
                <h3>Top 15 Municípios com Maior Temperatura Máxima</h3>
                <canvas id="chart-tem-max"></canvas>
            </div>
            <div class="chart-container">
                <h3>Top 15 Municípios com Maior Umidade Relativa</h3>
                <canvas id="chart-umd-max"></canvas>
            </div>
            <div class="chart-container">
                <h3>Top 15 Municípios com Maior Rajada de Vento</h3>
                <canvas id="chart-ven-max"></canvas>
            </div>
            <div class="chart-container">
                <h3>Top 15 Municípios com Menor Umidade Relativa</h3>
                <canvas id="chart-umd-min"></canvas>
            </div>
            <div class="chart-container">
                <h3>Top 15 Municípios com Menor Temperatura Mínima</h3>
                <canvas id="chart-tem-min"></canvas>
            </div>
        </div>

        <div id="data-tables-container"></div>
        <div id="dataSourceInfo" class="data-source-info" style="display: none;"></div>
    </div>
    <script>
        const API_BASE_URL = "https://apitempo.inmet.gov.br/token/estacao/dados";
        const API_TOKEN = "bDVzUzNIdEVUeXJMS3R6RmRZTDJjaFBLMDh3SU5yQk0=l5sS3HtETyrLKtzFdYL2chPK08wINrBM";

        const REGIOES = {
            'Norte': ['AC', 'AM', 'AP', 'PA', 'RO', 'RR', 'TO'],
            'Nordeste': ['AL', 'BA', 'CE', 'MA', 'PB', 'PE', 'PI', 'RN', 'SE'],
            'Sudeste': ['ES', 'MG', 'RJ', 'SP'],
            'Sul': ['PR', 'RS', 'SC'],
            'Centro-Oeste': ['GO', 'MT', 'MS', 'DF']
        };

        const CAPITAIS = {
            'AC': 'Rio Branco', 'AL': 'Maceió', 'AM': 'Manaus', 'AP': 'Macapá',
            'BA': 'Salvador', 'CE': 'Fortaleza', 'DF': 'Brasília', 'ES': 'Vitória',
            'GO': 'Goiânia', 'MA': 'São Luís', 'MG': 'Belo Horizonte', 'MS': 'Campo Grande',
            'MT': 'Cuiabá', 'PA': 'Belém', 'PB': 'João Pessoa', 'PE': 'Recife',
            'PI': 'Teresina', 'PR': 'Curitiba', 'RJ': 'Rio de Janeiro', 'RN': 'Natal',
            'RO': 'Porto Velho', 'RR': 'Boa Vista', 'RS': 'Porto Alegre', 'SC': 'Florianópolis',
            'SE': 'Aracaju', 'SP': 'São Paulo', 'TO': 'Palmas'
        };

        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        function updateDateTimeInfo() {
            const now = new Date();
            const lastRefresh = new Date(performance.timing.navigationStart);
            document.getElementById('currentDateTime').textContent = `Data e Hora Atual: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
            document.getElementById('lastRefreshTime').textContent = `Última atualização da página: ${formatTime(lastRefresh)}`;
        }

        /**
         * Limpa todos os gráficos existentes antes de criar novos.
         */
        function destroyExistingCharts() {
            const chartIds = ['chart-chuva-total', 'chart-tem-max', 'chart-umd-max', 'chart-ven-max', 'chart-umd-min', 'chart-tem-min'];
            chartIds.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas && canvas.chart) {
                    canvas.chart.destroy();
                }
            });
        }

        async function fetchHourData(dateString, hour) {
            const url = `${API_BASE_URL}/${dateString}/${hour}/${API_TOKEN}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    // Tenta ler o corpo da resposta em caso de erro, se disponível
                    const errorText = await response.text();
                    console.error(`Falha na resposta da rede (${response.status} ${response.statusText}) para ${url}: ${errorText}`);
                    throw new Error('Falha na resposta da rede');
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error(`Falha na requisição para ${url}:`, error);
                return [];
            }
        }

        /**
         * Cria a tabela de estações para uma UF específica.
         */
        function createUFTable(uf, stations) {
            const ufContainer = document.createElement('div');
            ufContainer.innerHTML = `<h3 class="uf-title">${uf}</h3>`;

            const table = document.createElement('table');
            table.id = `table-${uf}`;
            const thead = document.createElement('thead');
            const headers = ['Estação', 'UF', 'Temp. Máxima (°C)', 'Temp. Mínima (°C)', 'Umid. Máxima (%)', 'Umid. Mínima (%)', 'Vento Máximo (km/h)', 'Chuva Total (mm)'];
            const headerRow = document.createElement('tr');

            headers.forEach((text, index) => {
                const th = document.createElement('th');
                th.textContent = text;
                th.dataset.columnIndex = index;
                th.dataset.sortOrder = '';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            if (stations.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = headers.length;
                cell.textContent = "Nenhum dado encontrado para esta UF.";
                row.appendChild(cell);
                tbody.appendChild(row);
            } else {
                stations.forEach(station => {
                    const row = document.createElement('tr');
                    if (CAPITAIS[uf] && station.DC_NOME.includes(CAPITAIS[uf])) {
                        row.classList.add('capital-row');
                    }

                    const values = [
                        station.DC_NOME,
                        station.UF,
                        station.TEM_MAX !== -Infinity ? station.TEM_MAX.toFixed(1) : '-',
                        station.TEM_MIN !== Infinity ? station.TEM_MIN.toFixed(1) : '-',
                        station.UMD_MAX !== -Infinity ? station.UMD_MAX.toFixed(0) : '-',
                        station.UMD_MIN !== Infinity ? station.UMD_MIN.toFixed(0) : '-',
                        station.VEN_MAX !== -Infinity ? station.VEN_MAX.toFixed(1) : '-',
                        station.CHUVA_TOTAL !== undefined ? station.CHUVA_TOTAL.toFixed(2) : '-'
                    ];

                    values.forEach(cellData => {
                        const td = document.createElement('td');
                        td.textContent = cellData;
                        row.appendChild(td);
                    });
                    tbody.appendChild(row);
                });
            }
            table.appendChild(tbody);
            ufContainer.appendChild(table);
            return ufContainer;
        }

        function createRegionSummaryTable(regionalData) {
            const tableContainer = document.createElement('div');
            tableContainer.innerHTML = `<h2 class="region-title">Resumo por Região</h2>`;
            const table = document.createElement('table');
            table.id = 'table-summary';

            const thead = document.createElement('thead');
            const headers = ['Região', 'Temp. Máxima (°C)', 'Temp. Mínima (°C)', 'Umid. Máxima (%)', 'Umid. Mínima (%)', 'Vento Máximo (km/h)', 'Chuva Total (mm)'];
            const headerRow = document.createElement('tr');
            headers.forEach((text, index) => {
                const th = document.createElement('th');
                th.textContent = text;
                th.dataset.columnIndex = index;
                th.dataset.sortOrder = '';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            regionalData.forEach(data => {
                const row = document.createElement('tr');
                const values = [
                    data.region,
                    data.temMax !== -Infinity ? data.temMax.toFixed(1) : '-',
                    data.temMin !== Infinity ? data.temMin.toFixed(1) : '-',
                    data.umdMax !== -Infinity ? data.umdMax.toFixed(0) : '-',
                    data.umdMin !== Infinity ? data.umdMin.toFixed(0) : '-',
                    data.venMax !== -Infinity ? data.venMax.toFixed(1) : '-',
                    data.chuvaTotal !== undefined ? data.chuvaTotal.toFixed(2) : '-'
                ];
                values.forEach(cellData => {
                    const td = document.createElement('td');
                    td.textContent = cellData;
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });

            table.appendChild(tbody);
            tableContainer.appendChild(table);
            return tableContainer;
        }

        function createBarChart(elementId, title, label, data, labels, isDesc = true) {
            const ctx = document.getElementById(elementId).getContext('2d');
            
            // Certifique-se de que nenhum gráfico anterior com o mesmo ID está ativo
            const canvas = document.getElementById(elementId);
            if (canvas.chart) {
                canvas.chart.destroy();
            }
            
            const dataSorted = data.slice();
            const labelsSorted = labels.slice();

            // Lógica de ordenação (simplificada, pois o Chart.js não tem ordenação nativa simples)
            const sortedPairs = labelsSorted.map((label, i) => ({ label, data: dataSorted[i] }));
            sortedPairs.sort((a, b) => isDesc ? b.data - a.data : a.data - b.data);

            const finalLabels = sortedPairs.map(pair => pair.label);
            const finalData = sortedPairs.map(pair => pair.data);

            const colors = ['rgba(0, 150, 136, 0.6)', 'rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(255, 206, 86, 0.6)', 'rgba(75, 192, 192, 0.6)', 'rgba(153, 102, 255, 0.6)'];

            canvas.chart = new Chart(ctx, { // Armazena a instância do gráfico no canvas
                type: 'bar',
                data: {
                    labels: finalLabels.slice(0, 15),
                    datasets: [{
                        label: label,
                        data: finalData.slice(0, 15),
                        backgroundColor: (context) => {
                            const value = context.dataset.data[context.dataIndex];
                            if (value === -Infinity || value === Infinity) return 'rgba(128, 128, 128, 0.6)';
                            return colors[context.dataIndex % colors.length];
                        },
                        borderColor: 'rgba(0, 0, 0, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: label.split(' ')[0]
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: title
                        }
                    }
                }
            });
        }

        /**
         * Função principal de requisição e processamento, agora aceita a data.
         * @param {string} selectedDateString - Data selecionada no formato YYYY-MM-DD. Se vazio, usa a data atual.
         */
        async function fetchAndProcessData(selectedDateString = null) {
            updateDateTimeInfo();

            const LOADING_ANIMATION = document.getElementById('loading');
            const DATA_CONTAINER = document.getElementById('data-container');
            const DATA_TABLES_CONTAINER = document.getElementById('data-tables-container');
            const DATA_SOURCE_INFO = document.getElementById('dataSourceInfo');
            const SEARCH_BUTTON = document.getElementById('search-button');

            // Limpa gráficos anteriores
            destroyExistingCharts();
            DATA_TABLES_CONTAINER.innerHTML = '';
            DATA_SOURCE_INFO.style.display = 'none';

            LOADING_ANIMATION.style.display = 'block';
            DATA_CONTAINER.style.display = 'none';
            DATA_TABLES_CONTAINER.style.display = 'none';
            SEARCH_BUTTON.disabled = true; // Desabilita o botão durante a busca

            let targetDate, yesterday;

            if (selectedDateString) {
                // Se uma data foi selecionada, use-a para a busca.
                targetDate = new Date(selectedDateString + 'T12:00:00'); // Adiciona um horário para evitar problemas de fuso horário
                yesterday = new Date(targetDate);
                yesterday.setDate(targetDate.getDate() - 1);
            } else {
                // Comportamento padrão: hoje e ontem.
                targetDate = new Date();
                yesterday = new Date();
                yesterday.setDate(targetDate.getDate() - 1);
                // Preenche o campo de data com a data atual (padrão)
                document.getElementById('date-input').value = formatDate(targetDate);
            }

            const targetDateFormatted = formatDate(targetDate);
            const yesterdayFormatted = formatDate(yesterday);

            // Fetch dos dados: 00h às 23h da data alvo
            const requestsTarget = [];
            for (let i = 0; i <= 2300; i += 100) {
                requestsTarget.push(fetchHourData(targetDateFormatted, String(i).padStart(4, '0')));
            }
            const allDataTarget = (await Promise.all(requestsTarget)).flat();
            const validDataTarget = allDataTarget.filter(d => d && Object.keys(d).length > 0);

            // Fetch dos dados de precipitação: 13h às 23h da data anterior
            const requestsYesterday = [];
            for (let i = 1300; i <= 2300; i += 100) {
                requestsYesterday.push(fetchHourData(yesterdayFormatted, String(i).padStart(4, '0')));
            }
            const allDataYesterday = (await Promise.all(requestsYesterday)).flat();
            const validDataYesterday = allDataYesterday.filter(d => d && Object.keys(d).length > 0);

            const allData = [...validDataTarget, ...validDataYesterday];

            if (allData.length === 0) {
                LOADING_ANIMATION.innerHTML = `<p style="color: red;">Não foi possível carregar os dados para ${targetDateFormatted}. Por favor, verifique a data ou tente novamente mais tarde.</p>`;
                SEARCH_BUTTON.disabled = false;
                return;
            }

            const stationsData = {};

            // Processamento dos dados (máximas/mínimas do dia alvo)
            validDataTarget.forEach(current => {
                const stationId = current.CD_ESTACAO;
                if (!stationsData[stationId]) {
                    stationsData[stationId] = {
                        CD_ESTACAO: stationId,
                        DC_NOME: current.DC_NOME,
                        UF: current.UF,
                        TEM_MAX: -Infinity,
                        TEM_MIN: Infinity,
                        UMD_MAX: -Infinity,
                        UMD_MIN: Infinity,
                        VEN_MAX: -Infinity,
                        CHUVA_TOTAL: 0 // A chuva será calculada no loop seguinte
                    };
                }
                const temMax = parseFloat(current.TEM_MAX);
                if (!isNaN(temMax)) stationsData[stationId].TEM_MAX = Math.max(stationsData[stationId].TEM_MAX, temMax);
                const temMin = parseFloat(current.TEM_MIN);
                if (!isNaN(temMin)) stationsData[stationId].TEM_MIN = Math.min(stationsData[stationId].TEM_MIN, temMin);
                const umdMax = parseFloat(current.UMD_MAX);
                if (!isNaN(umdMax)) stationsData[stationId].UMD_MAX = Math.max(stationsData[stationId].UMD_MAX, umdMax);
                const umdMin = parseFloat(current.UMD_MIN);
                if (!isNaN(umdMin)) stationsData[stationId].UMD_MIN = Math.min(stationsData[stationId].UMD_MIN, umdMin);
                const venKmh = current.VEN_RAJ ? (parseFloat(current.VEN_RAJ) * 3.6) : NaN;
                if (!isNaN(venKmh)) stationsData[stationId].VEN_MAX = Math.max(stationsData[stationId].VEN_MAX, venKmh);
            });

            // Acumular Precipitação - Parte de 13h a 23h do dia anterior
            validDataYesterday.forEach(current => {
                const stationId = current.CD_ESTACAO;
                if (stationsData[stationId]) {
                    stationsData[stationId].CHUVA_TOTAL += parseFloat(current.CHUVA) || 0;
                }
            });

            // Acumular Precipitação - Parte de 00h a 12h do dia alvo
            validDataTarget.forEach(current => {
                const currentHour = parseInt(current.HR_MEDICAO);
                if (currentHour >= 0 && currentHour <= 1200) {
                    const stationId = current.CD_ESTACAO;
                    if (stationsData[stationId]) {
                        stationsData[stationId].CHUVA_TOTAL += parseFloat(current.CHUVA) || 0;
                    }
                }
            });

            const processedData = Object.values(stationsData);

            // --- Geração de Resumo Regional e Tabelas de UF (mantida) ---

            const regionalSummary = {};
            for (const [regiao, ufs] of Object.entries(REGIOES)) {
                regionalSummary[regiao] = {
                    region: regiao,
                    temMax: -Infinity,
                    temMin: Infinity,
                    umdMax: -Infinity,
                    umdMin: Infinity,
                    venMax: -Infinity,
                    chuvaTotal: 0
                };
                let hasData = false;
                ufs.forEach(uf => {
                    const stationsInUF = processedData.filter(d => d.UF === uf);
                    if (stationsInUF.length > 0) {
                        hasData = true;
                        stationsInUF.forEach(station => {
                            regionalSummary[regiao].temMax = Math.max(regionalSummary[regiao].temMax, station.TEM_MAX);
                            regionalSummary[regiao].temMin = Math.min(regionalSummary[regiao].temMin, station.TEM_MIN);
                            regionalSummary[regiao].umdMax = Math.max(regionalSummary[regiao].umdMax, station.UMD_MAX);
                            regionalSummary[regiao].umdMin = Math.min(regionalSummary[regiao].umdMin, station.UMD_MIN);
                            regionalSummary[regiao].venMax = Math.max(regionalSummary[regiao].venMax, station.VEN_MAX);
                            regionalSummary[regiao].chuvaTotal += station.CHUVA_TOTAL;
                        });
                    }
                });
                if (!hasData) {
                    regionalSummary[regiao] = null;
                }
            }

            const filteredRegionalSummary = Object.values(regionalSummary).filter(Boolean);

            if (filteredRegionalSummary.length > 0) {
                DATA_TABLES_CONTAINER.appendChild(createRegionSummaryTable(filteredRegionalSummary));
            }

            for (const [regiao, ufs] of Object.entries(REGIOES)) {
                const regionHeader = document.createElement('h2');
                regionHeader.className = 'region-title';
                regionHeader.textContent = `Região ${regiao}`;
                DATA_TABLES_CONTAINER.appendChild(regionHeader);

                let foundDataInRegion = false;
                ufs.forEach(uf => {
                    const stationsInUF = processedData.filter(d => d.UF === uf);
                    if (stationsInUF.length > 0) {
                        foundDataInRegion = true;
                        stationsInUF.sort((a, b) => {
                            const isCapitalA = a.DC_NOME.includes(CAPITAIS[uf]);
                            const isCapitalB = b.DC_NOME.includes(CAPITAIS[uf]);
                            if (isCapitalA && !isCapitalB) return -1;
                            if (!isCapitalA && isCapitalB) return 1;
                            return a.DC_NOME.localeCompare(b.DC_NOME);
                        });
                        DATA_TABLES_CONTAINER.appendChild(createUFTable(uf, stationsInUF));
                    }
                });

                if (!foundDataInRegion) {
                    const noDataParagraph = document.createElement('p');
                    noDataParagraph.textContent = 'Nenhum dado encontrado para esta região.';
                    DATA_TABLES_CONTAINER.appendChild(noDataParagraph);
                }
            }
            
            // --- Geração de Gráficos (mantida) ---

            const top15Chuva = processedData
                .filter(d => d.CHUVA_TOTAL !== undefined && d.CHUVA_TOTAL > 0)
                .sort((a, b) => b.CHUVA_TOTAL - a.CHUVA_TOTAL)
                .slice(0, 15);
            createBarChart('chart-chuva-total', 'Top 15 Municípios com Maior Precipitação', 'Precipitação (mm)', top15Chuva.map(d => d.CHUVA_TOTAL), top15Chuva.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15TempMax = processedData
                .filter(d => d.TEM_MAX !== -Infinity)
                .sort((a, b) => b.TEM_MAX - a.TEM_MAX)
                .slice(0, 15);
            createBarChart('chart-tem-max', 'Top 15 Municípios com Maior Temperatura Máxima', 'Temperatura (°C)', top15TempMax.map(d => d.TEM_MAX), top15TempMax.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15UmidMax = processedData
                .filter(d => d.UMD_MAX !== -Infinity)
                .sort((a, b) => b.UMD_MAX - a.UMD_MAX)
                .slice(0, 15);
            createBarChart('chart-umd-max', 'Top 15 Municípios com Maior Umidade Relativa', 'Umidade (%)', top15UmidMax.map(d => d.UMD_MAX), top15UmidMax.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15VenMax = processedData
                .filter(d => d.VEN_MAX !== -Infinity)
                .sort((a, b) => b.VEN_MAX - a.VEN_MAX)
                .slice(0, 15);
            createBarChart('chart-ven-max', 'Top 15 Municípios com Maior Rajada de Vento', 'Rajada de Vento (km/h)', top15VenMax.map(d => d.VEN_MAX), top15VenMax.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15UmidMin = processedData
                .filter(d => d.UMD_MIN !== Infinity)
                .sort((a, b) => a.UMD_MIN - b.UMD_MIN)
                .slice(0, 15);
            createBarChart('chart-umd-min', 'Top 15 Municípios com Menor Umidade Relativa', 'Umidade (%)', top15UmidMin.map(d => d.UMD_MIN), top15UmidMin.map(d => `${d.DC_NOME} - ${d.UF}`), false);

            const top15TempMin = processedData
                .filter(d => d.TEM_MIN !== Infinity)
                .sort((a, b) => a.TEM_MIN - b.TEM_MIN)
                .slice(0, 15);
            createBarChart('chart-tem-min', 'Top 15 Municípios com Menor Temperatura Mínima', 'Temperatura (°C)', top15TempMin.map(d => d.TEM_MIN), top15TempMin.map(d => `${d.DC_NOME} - ${d.UF}`), false);

            addSortableTableFunctionality();

            // --- Exibição Final ---
            
            let sourceInfoText = `Dados de 00h às 23h para temperatura/umidade/vento do dia **${targetDateFormatted}**. `;
            sourceInfoText += `Precipitação acumulada de 13h do dia **${yesterdayFormatted}** até 12h do dia **${targetDateFormatted}**.`;

            DATA_SOURCE_INFO.innerHTML = sourceInfoText;
            
            LOADING_ANIMATION.style.display = 'none';
            DATA_CONTAINER.style.display = 'block';
            DATA_TABLES_CONTAINER.style.display = 'block';
            DATA_SOURCE_INFO.style.display = 'block';
            SEARCH_BUTTON.disabled = false;
        }

        function getCellValue(tr, idx) {
            const cell = tr.children[idx];
            const value = cell.textContent || cell.innerText;
            const parsedValue = parseFloat(value.replace(',', '.'));
            return isNaN(parsedValue) ? value.trim() : parsedValue;
        }

        /**
         * Adiciona funcionalidade de ordenação às tabelas.
         */
        function addSortableTableFunctionality() {
            document.querySelectorAll('th[data-column-index]').forEach(headerCell => {
                headerCell.addEventListener('click', () => {
                    const table = headerCell.closest('table');
                    const tbody = table.querySelector('tbody');
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const isSummaryTable = table.id === 'table-summary';

                    const dataRows = rows.filter(row => row.children.length > 1);

                    const column = parseInt(headerCell.dataset.columnIndex);
                    let sortOrder = headerCell.dataset.sortOrder;

                    sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
                    headerCell.dataset.sortOrder = sortOrder;

                    headerCell.closest('tr').querySelectorAll('th').forEach(th => {
                        if (th !== headerCell) {
                            th.dataset.sortOrder = '';
                        }
                    });

                    // Índices de colunas que contêm dados numéricos
                    const numericColumnsSummary = [1, 2, 3, 4, 5, 6];
                    const numericColumnsStations = [2, 3, 4, 5, 6, 7]; // Ajustado para a coluna UF

                    const isNumeric = isSummaryTable
                        ? numericColumnsSummary.includes(column)
                        : numericColumnsStations.includes(column);

                    dataRows.sort((a, b) => {
                        let valA = getCellValue(a, column);
                        let valB = getCellValue(b, column);

                        if (isNumeric) {
                            // Tratar valores não-numéricos (como '-') para ordenação
                            valA = typeof valA === 'number' ? valA : (sortOrder === 'asc' ? Infinity : -Infinity);
                            valB = typeof valB === 'number' ? valB : (sortOrder === 'asc' ? Infinity : -Infinity);
                        } else {
                            valA = String(valA);
                            valB = String(valB);
                        }

                        const comparison = isNumeric ? valA - valB : valA.localeCompare(valB, 'pt-BR');
                        return sortOrder === 'asc' ? comparison : -comparison;
                    });

                    tbody.innerHTML = '';
                    dataRows.forEach(row => tbody.appendChild(row));

                    // Reaplicar a linha da capital no topo (se for tabela de UF)
                    if (!isSummaryTable) {
                        const ufTitle = headerCell.closest('div').querySelector('.uf-title');
                        if (ufTitle) {
                            const uf = ufTitle.textContent.trim();
                            const capitalRow = rows.find(row => row.classList.contains('capital-row'));
                            if (capitalRow) {
                                tbody.prepend(capitalRow);
                            }
                        }
                    }
                });
            });
        }

        // --- Novas Funções para a Busca por Data ---

        function handleDateSearch() {
            const dateInput = document.getElementById('date-input');
            const selectedDate = dateInput.value;

            if (selectedDate) {
                fetchAndProcessData(selectedDate);
            } else {
                alert('Por favor, selecione uma data para a busca.');
            }
        }

        function setMaxDate() {
            const today = new Date();
            // Permite buscar até o dia anterior (pois os dados do dia atual podem estar incompletos)
            // No entanto, como o código busca até 23h de hoje, a data máxima será o dia de hoje.
            document.getElementById('date-input').setAttribute('max', formatDate(today));
        }

        // --- Inicialização ---

        document.addEventListener('DOMContentLoaded', () => {
            setMaxDate();
            document.getElementById('search-button').addEventListener('click', handleDateSearch);
            fetchAndProcessData(); // Carrega os dados do dia atual por padrão
        });
    </script>
</body>
</html>
