<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <title id="pageTitle">DADOS METEOROLÓGICOS DETALHADOS POR REGIÃO</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <!-- <meta http-equiv="refresh" content="900">----->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #00796b;
            text-align: center;
        }
        .header-info {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 20px;
        }
        .region-title {
            color: #004d40;
            text-align: center;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 2px solid #004d40;
            padding-bottom: 5px;
        }
        .uf-title {
            color: #00897b;
            text-align: left;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.5em;
        }
        p {
            text-align: center;
            color: #666;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            background-color: #fff;
        }
        thead th {
            background-color: #009688;
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-weight: bold;
            cursor: pointer;
        }
        thead th:hover {
            background-color: #00796b;
        }
        tbody td {
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
        }
        tbody tr:nth-of-type(even) {
            background-color: #f9f9f9;
        }
        tbody tr:hover {
            background-color: #f1f1f1;
        }
        .capital-row {
            font-weight: bold;
            background-color: #bbdefb !important;
        }
        .loading-animation {
            text-align: center;
            margin-top: 50px;
        }
        .loading-animation img {
            width: 50px;
            height: 50px;
        }
        .data-source-info {
            font-size: 0.8em;
            color: #888;
            margin-top: 10px;
            text-align: center;
        }
        .container {
            max-width: 1200px;
            margin: auto;
        }
        .chart-container {
            width: 80%;
            margin: 40px auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        /* Novo estilo para destacar o aviso no topo da seção de dados */
        .data-info-top {
            font-size: 0.9em;
            color: #4CAF50;
            margin: 15px 0;
            padding: 10px;
            background-color: #e8f5e9;
            border: 1px solid #a5d6a7;
            border-radius: 4px;
            text-align: center;
        }
        /* Estilos para o seletor de idioma */
        .language-selector {
            text-align: right;
            margin-bottom: 10px;
        }
        .lang-button {
            background: none;
            border: 1px solid #ccc;
            padding: 5px 8px;
            margin-left: 5px;
            cursor: pointer;
            border-radius: 4px;
            opacity: 0.6;
            transition: opacity 0.2s, border-color 0.2s;
        }
        .lang-button:hover {
            opacity: 1;
            border-color: #009688;
        }
        .lang-button.active {
            opacity: 1;
            border-color: #00796b;
            background-color: #e0f2f1;
        }
        .lang-button img {
            width: 20px;
            height: 15px;
            vertical-align: middle;
        }

        /* Estilos do seletor de data (opção 2) */
        .date-selector {
            text-align: center;
            margin: 10px 0 25px;
        }
        .date-selector input[type="date"] {
            padding: 6px 8px;
            font-size: 1em;
            border-radius: 4px;
            border: 1px solid #ccc;
            margin-right: 8px;
        }
        .date-selector button {
            padding: 7px 12px;
            font-size: 1em;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            background-color: #009688;
            color: white;
        }
        .date-selector button:hover {
            background-color: #00796b;
        }
    </style>
</head>
<body onload="setLanguage('pt')">
<!-- ======================= AUTO-ATUALIZAÇÃO ======================= -->
<div style="position: fixed; top: 10px; right: 10px; z-index: 9999; background: #fff; padding: 8px; border: 1px solid #000; border-radius: 6px;">
    <label style="font-weight: bold; cursor:pointer;">
        <input type="checkbox" id="toggleAutoReload" checked>
        Atualização Automática (a cada 15 minutos)
    </label>
</div>

<script>
    // Intervalo de atualização (900.000 ms = 15 minutos)
    let reloadInterval = 900000;
    let autoReloadAtivo = true;
    let reloadTimer = null;

    function iniciarAutoReload() {
        pararAutoReload();
        reloadTimer = setInterval(() => {
            if (autoReloadAtivo) location.reload();
        }, reloadInterval);
    }

    function pararAutoReload() {
        if (reloadTimer) clearInterval(reloadTimer);
    }

    // Controle do checkbox
    document.getElementById("toggleAutoReload").addEventListener("change", function () {
        autoReloadAtivo = this.checked;

        if (autoReloadAtivo) {
            iniciarAutoReload();
        } else {
            pararAutoReload();
        }
    });

    // Inicia automático ao carregar a página
    iniciarAutoReload();
</script>
<!-- ================================================================ -->


    
    <div class="container">
        <div class="language-selector">
            <button class="lang-button active" onclick="setLanguage('pt')" id="lang-pt" title="Português">
                <img src="data:image/png;base64,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" alt="Bandeira do Brasil"> PT
            </button>
            <button class="lang-button" onclick="setLanguage('es')" id="lang-es" title="Español">
                <img src="data:image/png;base64,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" alt="Bandera de España"> ES
            </button>
            <button class="lang-button" onclick="setLanguage('en')" id="lang-en" title="English">
                <img src="data:image/png;base64,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" alt="Flag of United Kingdom"> EN
            </button>
        </div>
        <h1 id="mainTitle">Dados Meteorológicos por Estação e Região</h1>
        <p id="subTitle">Dados de todas as estações do INMET no Brasil.</p>

        <div class="header-info">
            <p id="currentDateTime"></p>
            <p id="lastRefreshTime"></p>
        </div>

        <div class="loading-animation" id="loading">
            <img src="https://i.imgur.com/u7sA5mF.gif" alt="Carregando...">
            <p id="loadingText">Carregando dados, por favor aguarde...</p>
        </div>

        <div id="data-container" style="display: none;">
            <div id="dataSourceInfoTop" class="data-source-info data-info-top" style="display: none;"></div>
            
            <!-- OPÇÃO 2: seletor de data acima de "Gráficos de Destaque" -->
            <div class="date-selector" id="dateSelectorContainer">
                <input type="date" id="selectedDate" />
                <button id="loadDateButton">Carregar dia escolhido</button>
            </div>

            <h2 class="region-title" id="chartHeader">Gráficos de Destaque</h2>
            <div class="chart-container">
                <h3 id="chartTitleChuva">Top 15 Municípios com Maior Precipitação</h3>
                <canvas id="chart-chuva-total"></canvas>
            </div>
            <div class="chart-container">
                <h3 id="chartTitleTempMax">Top 15 Municípios com Maior Temperatura Máxima</h3>
                <canvas id="chart-tem-max"></canvas>
            </div>
            <div class="chart-container">
                <h3 id="chartTitleUmdMax">Top 15 Municípios com Maior Umidade Relativa</h3>
                <canvas id="chart-umd-max"></canvas>
            </div>
            <div class="chart-container">
                <h3 id="chartTitleVenMax">Top 15 Municípios com Maior Rajada de Vento</h3>
                <canvas id="chart-ven-max"></canvas>
            </div>
            <div class="chart-container">
                <h3 id="chartTitleUmdMin">Top 15 Municípios com Menor Umidade Relativa</h3>
                <canvas id="chart-umd-min"></canvas>
            </div>
            <div class="chart-container">
                <h3 id="chartTitleTempMin">Top 15 Municípios com Menor Temperatura Mínima</h3>
                <canvas id="chart-tem-min"></canvas>
            </div>
        </div>

        <div id="data-tables-container"></div>
        <div id="dataSourceInfoBottom" class="data-source-info" style="display: none;"></div>
    </div>
    <script>
        const API_BASE_URL = "https://apitempo.inmet.gov.br/token/estacao/dados";
        const API_TOKEN = "bDVzUzNIdEVUeXJMS3R6RmRZTDJjaFBLMDh3SU5yQk0=l5sS3HtETyrLKtzFdYL2chPK08wINrBM";

        const REGIOES = {
            'Norte': ['AC', 'AM', 'AP', 'PA', 'RO', 'RR', 'TO'],
            'Nordeste': ['AL', 'BA', 'CE', 'MA', 'PB', 'PE', 'PI', 'RN', 'SE'],
            'Sudeste': ['ES', 'MG', 'RJ', 'SP'],
            'Sul': ['PR', 'RS', 'SC'],
            'Centro-Oeste': ['GO', 'MT', 'MS', 'DF']
        };

        const CAPITAIS = {
            'AC': 'Rio Branco', 'AL': 'Maceió', 'AM': 'Manaus', 'AP': 'Macapá',
            'BA': 'Salvador', 'CE': 'Fortaleza', 'DF': 'Brasília', 'ES': 'Vitória',
            'GO': 'Goiânia', 'MA': 'São Luís', 'MG': 'Belo Horizonte', 'MS': 'Campo Grande',
            'MT': 'Cuiabá', 'PA': 'Belém', 'PB': 'João Pessoa', 'PE': 'Recife',
            'PI': 'Teresina', 'PR': 'Curitiba', 'RJ': 'Rio de Janeiro', 'RN': 'Natal',
            'RO': 'Porto Velho', 'RR': 'Boa Vista', 'RS': 'Porto Alegre', 'SC': 'Florianópolis',
            'SE': 'Aracaju', 'SP': 'São Paulo', 'TO': 'Palmas'
        };

        // --- OBJETOS DE TRADUÇÃO ---
        const translations = {
            'pt': {
                pageTitle: 'DADOS METEOROLÓGICOS DETALHADOS POR REGIÃO',
                mainTitle: 'Dados Meteorológicos por Estação e Região',
                subTitle: 'Dados de todas as estações do INMET no Brasil.',
                loadingText: 'Carregando dados, por favor aguarde...',
                currentDateTime: 'Data e Hora Atual',
                lastRefreshTime: 'Última atualização da página',
                chartHeader: 'Gráficos de Destaque',
                chartTitleChuva: 'Top 15 Municípios com Maior Precipitação',
                chartTitleTempMax: 'Top 15 Municípios com Maior Temperatura Máxima',
                chartTitleUmdMax: 'Top 15 Municípios com Maior Umidade Relativa',
                chartTitleVenMax: 'Top 15 Municípios com Maior Rajada de Vento',
                chartTitleUmdMin: 'Top 15 Municípios com Menor Umidade Relativa',
                chartTitleTempMin: 'Top 15 Municípios com Menor Temperatura Mínima',
                regionHeader: 'Região',
                summaryHeader: 'Resumo por Região',
                ufNoData: 'Nenhum dado encontrado para esta UF.',
                regionNoData: 'Nenhum dado encontrado para esta região.',
                sourceText: (today, yesterday) => `Dados de 00h às 23h para temperatura/umidade/vento do dia ${today}. Precipitação acumulada de 13h do dia ${yesterday} até 12h do dia ${today}.`,
                tableHeaders: {
                    station: 'Estação',
                    uf: 'UF',
                    tempMax: 'Temp. Máxima (°C)',
                    tempMin: 'Temp. Mínima (°C)',
                    umdMax: 'Umid. Máxima (%)',
                    umdMin: 'Umid. Mínima (%)',
                    venMax: 'Vento Máximo (km/h)',
                    chuvaTotal: 'Chuva Total (mm)',
                    region: 'Região'
                },
                chartLabels: {
                    chuva: 'Precipitação (mm)',
                    temp: 'Temperatura (°C)',
                    umd: 'Umidade (%)',
                    vento: 'Rajada de Vento (km/h)'
                }
            },
            'es': {
                pageTitle: 'DATOS METEOROLÓGICOS DETALLADOS POR REGIÓN',
                mainTitle: 'Datos Meteorológicos por Estación y Región',
                subTitle: 'Datos de todas las estaciones de INMET en Brasil.',
                loadingText: 'Cargando datos, por favor espere...',
                currentDateTime: 'Fecha y Hora Actual',
                lastRefreshTime: 'Última actualización de la página',
                chartHeader: 'Gráficos Destacados',
                chartTitleChuva: 'Top 15 Municipios con Mayor Precipitación',
                chartTitleTempMax: 'Top 15 Municipios con Mayor Temperatura Máxima',
                chartTitleUmdMax: 'Top 15 Municipios con Mayor Humedad Relativa',
                chartTitleVenMax: 'Top 15 Municipios con Mayor Ráfaga de Viento',
                chartTitleUmdMin: 'Top 15 Municipios con Menor Humedad Relativa',
                chartTitleTempMin: 'Top 15 Municipios con Menor Temperatura Mínima',
                regionHeader: 'Región',
                summaryHeader: 'Resumen por Región',
                ufNoData: 'No se encontraron datos para este estado.',
                regionNoData: 'No se encontraron datos para esta región.',
                sourceText: (today, yesterday) => `Datos de 00h a 23h para temperatura/humedad/viento del día ${today}. Precipitación acumulada de 13h del día ${yesterday} hasta 12h del día ${today}.`,
                tableHeaders: {
                    station: 'Estación',
                    uf: 'Estado (UF)',
                    tempMax: 'Temp. Máxima (°C)',
                    tempMin: 'Temp. Mínima (°C)',
                    umdMax: 'Hum. Máxima (%)',
                    umdMin: 'Hum. Mínima (%)',
                    venMax: 'Viento Máximo (km/h)',
                    chuvaTotal: 'Lluvia Total (mm)',
                    region: 'Región'
                },
                chartLabels: {
                    chuva: 'Precipitación (mm)',
                    temp: 'Temperatura (°C)',
                    umd: 'Humedad (%)',
                    vento: 'Ráfaga de Viento (km/h)'
                }
            },
            'en': {
                pageTitle: 'DETAILED METEOROLOGICAL DATA BY REGION',
                mainTitle: 'Meteorological Data by Station and Region',
                subTitle: 'Data from all INMET stations in Brazil.',
                loadingText: 'Loading data, please wait...',
                currentDateTime: 'Current Date and Time',
                lastRefreshTime: 'Last page refresh',
                chartHeader: 'Featured Charts',
                chartTitleChuva: 'Top 15 Municipalities with Highest Rainfall',
                chartTitleTempMax: 'Top 15 Municipalities with Highest Maximum Temperature',
                chartTitleUmdMax: 'Top 15 Municipalities with Highest Relative Humidity',
                chartTitleVenMax: 'Top 15 Municipalities with Highest Wind Gust',
                chartTitleUmdMin: 'Top 15 Municipalities with Lowest Relative Humidity',
                chartTitleTempMin: 'Top 15 Municipalities with Lowest Minimum Temperature',
                regionHeader: 'Region',
                summaryHeader: 'Summary by Region',
                ufNoData: 'No data found for this state.',
                regionNoData: 'No data found for this region.',
                sourceText: (today, yesterday) => `Data from 00h to 23h for temperature/humidity/wind on ${today}. Accumulated rainfall from 13h on ${yesterday} to 12h on ${today}.`,
                tableHeaders: {
                    station: 'Station',
                    uf: 'State (UF)',
                    tempMax: 'Max Temp. (°C)',
                    tempMin: 'Min Temp. (°C)',
                    umdMax: 'Max Hum. (%)',
                    umdMin: 'Min Hum. (%)',
                    venMax: 'Max Wind (km/h)',
                    chuvaTotal: 'Total Rainfall (mm)',
                    region: 'Region'
                },
                chartLabels: {
                    chuva: 'Rainfall (mm)',
                    temp: 'Temperature (°C)',
                    umd: 'Humidity (%)',
                    vento: 'Wind Gust (km/h)'
                }
            }
        };

        let currentLang = 'pt';
        
        // --- FUNÇÃO PARA TROCA DE IDIOMA (AJUSTADA) ---
        function setLanguage(lang) {
            currentLang = lang;
            const t = translations[lang];

            // 1. Atualizar HTML estático
            document.getElementById('pageTitle').textContent = t.pageTitle;
            document.getElementById('mainTitle').textContent = t.mainTitle;
            document.getElementById('subTitle').textContent = t.subTitle;
            document.getElementById('loadingText').textContent = t.loadingText;
            document.getElementById('chartHeader').textContent = t.chartHeader;
            document.getElementById('chartTitleChuva').textContent = t.chartTitleChuva;
            document.getElementById('chartTitleTempMax').textContent = t.chartTitleTempMax;
            document.getElementById('chartTitleUmdMax').textContent = t.chartTitleUmdMax;
            document.getElementById('chartTitleVenMax').textContent = t.chartTitleVenMax;
            document.getElementById('chartTitleUmdMin').textContent = t.chartTitleUmdMin;
            document.getElementById('chartTitleTempMin').textContent = t.chartTitleTempMin;

            // 2. Atualizar Botões Ativos
            document.querySelectorAll('.lang-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`lang-${lang}`).classList.add('active');

            // 3. Re-renderizar dados dinâmicos (e tabelas) se já estiverem carregados
            // Ajuste: passar reRender=true sem alterar a data selecionada
            fetchAndProcessData(null, true);
        }
        // --- FIM FUNÇÃO PARA TROCA DE IDIOMA ---

        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        function updateDateTimeInfo() {
            const t = translations[currentLang];
            const now = new Date();
            const lastRefresh = new Date(performance.timing.navigationStart);
            document.getElementById('currentDateTime').textContent = `${t.currentDateTime}: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
            document.getElementById('lastRefreshTime').textContent = `${t.lastRefreshTime}: ${formatTime(lastRefresh)}`;
        }

        async function fetchHourData(dateString, hour) {
            const url = `${API_BASE_URL}/${dateString}/${hour}/${API_TOKEN}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Falha na resposta da rede');
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error(`Falha na requisição para ${url}:`, error);
                return [];
            }
        }

        /**
         * Cria a tabela de estações para uma UF específica.
         * MODIFICADO: Usa os headers traduzidos.
         */
        function createUFTable(uf, stations) {
            const t = translations[currentLang];
            const ufContainer = document.createElement('div');
            ufContainer.innerHTML = `<h3 class="uf-title">${uf}</h3>`;

            const table = document.createElement('table');
            table.id = `table-${uf}`;
            const thead = document.createElement('thead');
            
            // Usando os headers traduzidos do objeto
            const headers = [
                t.tableHeaders.station, 
                t.tableHeaders.uf, 
                t.tableHeaders.tempMax, 
                t.tableHeaders.tempMin, 
                t.tableHeaders.umdMax, 
                t.tableHeaders.umdMin, 
                t.tableHeaders.venMax, 
                t.tableHeaders.chuvaTotal
            ];
            const headerRow = document.createElement('tr');

            headers.forEach((text, index) => {
                const th = document.createElement('th');
                th.textContent = text;
                th.dataset.columnIndex = index;
                th.dataset.sortOrder = '';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            if (stations.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = headers.length;
                cell.textContent = t.ufNoData;
                row.appendChild(cell);
                tbody.appendChild(row);
            } else {
                stations.forEach(station => {
                    const row = document.createElement('tr');
                    if (CAPITAIS[uf] && station.DC_NOME.includes(CAPITAIS[uf])) {
                        row.classList.add('capital-row');
                    }
                    
                    const values = [
                        station.DC_NOME,
                        station.UF,
                        station.TEM_MAX !== -Infinity ? station.TEM_MAX.toFixed(1) : '-',
                        station.TEM_MIN !== Infinity ? station.TEM_MIN.toFixed(1) : '-',
                        station.UMD_MAX !== -Infinity ? station.UMD_MAX.toFixed(0) : '-',
                        station.UMD_MIN !== Infinity ? station.UMD_MIN.toFixed(0) : '-',
                        station.VEN_MAX !== -Infinity ? station.VEN_MAX.toFixed(1) : '-',
                        station.CHUVA_TOTAL !== undefined ? station.CHUVA_TOTAL.toFixed(2) : '-'
                    ];

                    values.forEach(cellData => {
                        const td = document.createElement('td');
                        td.textContent = cellData;
                        row.appendChild(td);
                    });
                    tbody.appendChild(row);
                });
            }
            table.appendChild(tbody);
            ufContainer.appendChild(table);
            return ufContainer;
        }

        /**
         * Cria a tabela de resumo regional.
         * MODIFICADO: Usa os headers traduzidos.
         */
        function createRegionSummaryTable(regionalData) {
            const t = translations[currentLang];
            const tableContainer = document.createElement('div');
            tableContainer.innerHTML = `<h2 class="region-title">${t.summaryHeader}</h2>`;
            const table = document.createElement('table');
            table.id = 'table-summary';

            const thead = document.createElement('thead');
            // Usando os headers traduzidos do objeto
            const headers = [
                t.tableHeaders.region, 
                t.tableHeaders.tempMax, 
                t.tableHeaders.tempMin, 
                t.tableHeaders.umdMax, 
                t.tableHeaders.umdMin, 
                t.tableHeaders.venMax, 
                t.tableHeaders.chuvaTotal
            ];
            const headerRow = document.createElement('tr');
            headers.forEach((text, index) => {
                const th = document.createElement('th');
                th.textContent = text;
                th.dataset.columnIndex = index;
                th.dataset.sortOrder = '';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            regionalData.forEach(data => {
                const row = document.createElement('tr');
                const values = [
                    data.region,
                    data.temMax !== -Infinity ? data.temMax.toFixed(1) : '-',
                    data.temMin !== Infinity ? data.temMin.toFixed(1) : '-',
                    data.umdMax !== -Infinity ? data.umdMax.toFixed(0) : '-',
                    data.umdMin !== Infinity ? data.umdMin.toFixed(0) : '-',
                    data.venMax !== -Infinity ? data.venMax.toFixed(1) : '-',
                    data.chuvaTotal !== undefined ? data.chuvaTotal.toFixed(2) : '-'
                ];
                values.forEach(cellData => {
                    const td = document.createElement('td');
                    td.textContent = cellData;
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });

            table.appendChild(tbody);
            tableContainer.appendChild(table);
            return tableContainer;
        }

        /**
         * Cria gráfico de barras.
         * MODIFICADO: Usa os títulos e labels traduzidos.
         */
        function createBarChart(elementId, titleKey, labelKey, data, labels, isDesc = true) {
            const t = translations[currentLang];
            // Destrói o gráfico anterior (se existir) para evitar duplicação ou conflito de dados
            const oldChart = Chart.getChart(elementId);
            if (oldChart) {
                oldChart.destroy();
            }

            const ctx = document.getElementById(elementId).getContext('2d');
            const dataSorted = data.slice();
            const labelsSorted = labels.slice();

            // Reordenar os dados para o gráfico (Top 15)
            if (isDesc) {
                const sortedPairs = labelsSorted.map((label, i) => ({ label, data: dataSorted[i] })).sort((a, b) => b.data - a.data);
                labelsSorted.length = 0;
                dataSorted.length = 0;
                sortedPairs.forEach(pair => {
                    labelsSorted.push(pair.label);
                    dataSorted.push(pair.data);
                });
            } else {
                const sortedPairs = labelsSorted.map((label, i) => ({ label, data: dataSorted[i] })).sort((a, b) => a.data - b.data);
                labelsSorted.length = 0;
                dataSorted.length = 0;
                sortedPairs.forEach(pair => {
                    labelsSorted.push(pair.label);
                    dataSorted.push(pair.data);
                });
            }

            const labelText = t.chartLabels[labelKey];

            const colors = ['rgba(0, 150, 136, 0.6)', 'rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(255, 206, 86, 0.6)', 'rgba(75, 192, 192, 0.6)', 'rgba(153, 102, 255, 0.6)'];

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labelsSorted,
                    datasets: [{
                        label: labelText,
                        data: dataSorted,
                        backgroundColor: (context) => {
                            const value = context.dataset.data[context.dataIndex];
                            if (value === -Infinity || value === Infinity) return 'rgba(128, 128, 128, 0.6)';
                            return colors[context.dataIndex % colors.length];
                        },
                        borderColor: 'rgba(0, 0, 0, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: labelText
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: translations[currentLang][titleKey]
                        }
                    }
                }
            });
        }
        
        // Armazenar dados processados para não recarregar em troca de idioma
        let cachedProcessedData = null;
        let cachedRegionalSummary = null;
        let cachedDateUsed = null; // para saber qual data os caches representam

        /**
         * Função principal de carregamento e processamento.
         * Parâmetros:
         *  - selectedDate (string 'YYYY-MM-DD' ou null para hoje)
         *  - reRender (boolean) -> se true e existe cache, apenas re-renderiza (troca de idioma)
         */
        async function fetchAndProcessData(selectedDate = null, reRender = false) {
            // Compatibilidade: se a função for chamada com apenas um boolean (por engano),
            // ajustar os parâmetros.
            if (typeof selectedDate === 'boolean') {
                reRender = selectedDate;
                selectedDate = null;
            }

            updateDateTimeInfo();

            const LOADING_ANIMATION = document.getElementById('loading');
            const DATA_CONTAINER = document.getElementById('data-container');
            const DATA_TABLES_CONTAINER = document.getElementById('data-tables-container');
            const DATA_SOURCE_INFO_BOTTOM = document.getElementById('dataSourceInfoBottom');
            const DATA_SOURCE_INFO_TOP = document.getElementById('dataSourceInfoTop');

            let processedData = null;
            let filteredRegionalSummary = null;

            // Determinar data alvo: se selectedDate fornecida, usar ela; senão usar hoje
            const dateToUse = selectedDate ? new Date(selectedDate + "T00:00:00") : new Date();
            const todayFormatted = formatDate(dateToUse);

            // Dia anterior relativo a data escolhida (X1)
            const yesterdayDate = new Date(dateToUse);
            yesterdayDate.setDate(dateToUse.getDate() - 1);
            const yesterdayFormatted = formatDate(yesterdayDate);

            // Se reRender === true e cache existe para a MESMA data, apenas re-renderizar (troca idioma)
            if (reRender && cachedProcessedData && cachedDateUsed === todayFormatted) {
                processedData = cachedProcessedData;
                filteredRegionalSummary = cachedRegionalSummary;
            } else {
                // Se reRender solicitado mas cache é de outra data, precisamos refazer fetch para a nova data.
                // Exibir loading.
                LOADING_ANIMATION.style.display = 'block';
                DATA_CONTAINER.style.display = 'none';
                DATA_TABLES_CONTAINER.style.display = 'none';
                DATA_SOURCE_INFO_BOTTOM.style.display = 'none';
                DATA_SOURCE_INFO_TOP.style.display = 'none';

                // Realizar fetch dos horários do dia escolhido (00:00..23:00) e do dia anterior (13:00..23:00)
                const requestsToday = [];
                for (let i = 0; i <= 2300; i += 100) {
                    const hourStr = String(i).padStart(4, '0');
                    requestsToday.push(fetchHourData(todayFormatted, hourStr));
                }
                const allDataToday = (await Promise.all(requestsToday)).flat();
                const validDataToday = allDataToday.filter(d => d && Object.keys(d).length > 0);

                const requestsYesterday = [];
                for (let i = 1300; i <= 2300; i += 100) {
                    const hourStr = String(i).padStart(4, '0');
                    requestsYesterday.push(fetchHourData(yesterdayFormatted, hourStr));
                }
                const allDataYesterday = (await Promise.all(requestsYesterday)).flat();
                const validDataYesterday = allDataYesterday.filter(d => d && Object.keys(d).length > 0);

                const allData = [...validDataToday, ...validDataYesterday];

                if (allData.length === 0) {
                    LOADING_ANIMATION.innerHTML = `<p style="color: red;">${translations[currentLang].loadingText.replace('Carregando dados, por favor aguarde...', 'Não foi possível carregar os dados. Por favor, tente novamente mais tarde.')}</p>`;
                    return;
                }

                const stationsData = {};

                // Processar medidas do "today" (00h-23h) para TEM/UMD/VEN máximos/minimos
                validDataToday.forEach(current => {
                    const stationId = current.CD_ESTACAO;
                    if (!stationsData[stationId]) {
                        stationsData[stationId] = {
                            CD_ESTACAO: stationId,
                            DC_NOME: current.DC_NOME,
                            UF: current.UF,
                            TEM_MAX: -Infinity,
                            TEM_MIN: Infinity,
                            UMD_MAX: -Infinity,
                            UMD_MIN: Infinity,
                            VEN_MAX: -Infinity,
                            CHUVA_TOTAL: 0
                        };
                    }
                    const temMax = parseFloat(current.TEM_MAX);
                    if (!isNaN(temMax)) stationsData[stationId].TEM_MAX = Math.max(stationsData[stationId].TEM_MAX, temMax);
                    const temMin = parseFloat(current.TEM_MIN);
                    if (!isNaN(temMin)) stationsData[stationId].TEM_MIN = Math.min(stationsData[stationId].TEM_MIN, temMin);
                    const umdMax = parseFloat(current.UMD_MAX);
                    if (!isNaN(umdMax)) stationsData[stationId].UMD_MAX = Math.max(stationsData[stationId].UMD_MAX, umdMax);
                    const umdMin = parseFloat(current.UMD_MIN);
                    if (!isNaN(umdMin)) stationsData[stationId].UMD_MIN = Math.min(stationsData[stationId].UMD_MIN, umdMin);
                    const venKmh = current.VEN_RAJ ? (parseFloat(current.VEN_RAJ) * 3.6) : NaN;
                    if (!isNaN(venKmh)) stationsData[stationId].VEN_MAX = Math.max(stationsData[stationId].VEN_MAX, venKmh);
                });

                // Acumular CHUVA: parte do dia anterior (13h-23h) + parte do dia escolhido (00h-12h)
                validDataYesterday.forEach(current => {
                    const stationId = current.CD_ESTACAO;
                    if (stationsData[stationId]) {
                        stationsData[stationId].CHUVA_TOTAL += parseFloat(current.CHUVA) || 0;
                    } else {
                        // Caso exista chuva no dia anterior para estação que não apareceu em validDataToday,
                        // ainda assim criar a entrada (manter compatibilidade)
                        stationsData[stationId] = {
                            CD_ESTACAO: stationId,
                            DC_NOME: current.DC_NOME || ('Estação ' + stationId),
                            UF: current.UF || '??',
                            TEM_MAX: -Infinity,
                            TEM_MIN: Infinity,
                            UMD_MAX: -Infinity,
                            UMD_MIN: Infinity,
                            VEN_MAX: -Infinity,
                            CHUVA_TOTAL: parseFloat(current.CHUVA) || 0
                        };
                    }
                });

                // Somar chuva do dia escolhido somente entre 00h e 12h (como na regra original)
                validDataToday.forEach(current => {
                    const currentHour = parseInt(current.HR_MEDICAO);
                    if (!isNaN(currentHour) && currentHour >= 0 && currentHour <= 1200) {
                        const stationId = current.CD_ESTACAO;
                        if (stationsData[stationId]) {
                            stationsData[stationId].CHUVA_TOTAL += parseFloat(current.CHUVA) || 0;
                        } else {
                            stationsData[stationId] = {
                                CD_ESTACAO: stationId,
                                DC_NOME: current.DC_NOME,
                                UF: current.UF,
                                TEM_MAX: -Infinity,
                                TEM_MIN: Infinity,
                                UMD_MAX: -Infinity,
                                UMD_MIN: Infinity,
                                VEN_MAX: -Infinity,
                                CHUVA_TOTAL: parseFloat(current.CHUVA) || 0
                            };
                        }
                    }
                });

                processedData = Object.values(stationsData);
                cachedProcessedData = processedData; // Cache
                cachedDateUsed = todayFormatted;

                // Montar resumo regional
                const regionalSummary = {};
                for (const [regiao, ufs] of Object.entries(REGIOES)) {
                    regionalSummary[regiao] = {
                        region: regiao,
                        temMax: -Infinity,
                        temMin: Infinity,
                        umdMax: -Infinity,
                        umdMin: Infinity,
                        venMax: -Infinity,
                        chuvaTotal: 0
                    };
                    let hasData = false;
                    ufs.forEach(uf => {
                        const stationsInUF = processedData.filter(d => d.UF === uf);
                        if (stationsInUF.length > 0) {
                            hasData = true;
                            stationsInUF.forEach(station => {
                                regionalSummary[regiao].temMax = Math.max(regionalSummary[regiao].temMax, station.TEM_MAX);
                                regionalSummary[regiao].temMin = Math.min(regionalSummary[regiao].temMin, station.TEM_MIN);
                                regionalSummary[regiao].umdMax = Math.max(regionalSummary[regiao].umdMax, station.UMD_MAX);
                                regionalSummary[regiao].umdMin = Math.min(regionalSummary[regiao].umdMin, station.UMD_MIN);
                                regionalSummary[regiao].venMax = Math.max(regionalSummary[regiao].venMax, station.VEN_MAX);
                                regionalSummary[regiao].chuvaTotal += station.CHUVA_TOTAL;
                            });
                        }
                    });
                    if (!hasData) {
                        regionalSummary[regiao] = null;
                    }
                }
                filteredRegionalSummary = Object.values(regionalSummary).filter(Boolean);
                cachedRegionalSummary = filteredRegionalSummary; // Cache
            }

            // --- RENDERIZAÇÃO ---
            DATA_TABLES_CONTAINER.innerHTML = '';

            if (filteredRegionalSummary && filteredRegionalSummary.length > 0) {
                DATA_TABLES_CONTAINER.appendChild(createRegionSummaryTable(filteredRegionalSummary));
            }

            // Distrito Federal com prioridade
            const dfStations = processedData.filter(d => d.UF === 'DF');
            if (dfStations.length > 0) {
                dfStations.sort((a, b) => {
                    const isCapitalA = a.DC_NOME.includes(CAPITAIS['DF']);
                    const isCapitalB = b.DC_NOME.includes(CAPITAIS['DF']);
                    if (isCapitalA && !isCapitalB) return -1;
                    if (!isCapitalA && isCapitalB) return 1;
                    return a.DC_NOME.localeCompare(b.DC_NOME);
                });

                const dfRegionHeader = document.createElement('h2');
                dfRegionHeader.className = 'region-title';
                dfRegionHeader.textContent = `${translations[currentLang].regionHeader} Centro-Oeste (DF)`;
                DATA_TABLES_CONTAINER.appendChild(dfRegionHeader);

                DATA_TABLES_CONTAINER.appendChild(createUFTable('DF', dfStations));
            }

            // Tabelas por região/UF
            for (const [regiao, ufs] of Object.entries(REGIOES)) {
                const ufsToProcess = ufs.filter(uf => uf !== 'DF');

                if (ufsToProcess.length > 0) {
                    const regionHeader = document.createElement('h2');
                    regionHeader.className = 'region-title';
                    regionHeader.textContent = `${translations[currentLang].regionHeader} ${regiao}`;
                    DATA_TABLES_CONTAINER.appendChild(regionHeader);

                    let foundDataInRegion = false;
                    ufsToProcess.forEach(uf => {
                        const stationsInUF = processedData.filter(d => d.UF === uf);
                        if (stationsInUF.length > 0) {
                            foundDataInRegion = true;
                            stationsInUF.sort((a, b) => {
                                const isCapitalA = a.DC_NOME.includes(CAPITAIS[uf]);
                                const isCapitalB = b.DC_NOME.includes(CAPITAIS[uf]);
                                if (isCapitalA && !isCapitalB) return -1;
                                if (!isCapitalA && isCapitalB) return 1;
                                return a.DC_NOME.localeCompare(b.DC_NOME);
                            });
                            DATA_TABLES_CONTAINER.appendChild(createUFTable(uf, stationsInUF));
                        }
                    });

                    if (!foundDataInRegion && ufsToProcess.length > 0) {
                        const noDataParagraph = document.createElement('p');
                        noDataParagraph.textContent = translations[currentLang].regionNoData;
                        DATA_TABLES_CONTAINER.appendChild(noDataParagraph);
                    }
                }
            }

            // Gráficos de destaque
            const top15Chuva = processedData
                .filter(d => d.CHUVA_TOTAL !== undefined && d.CHUVA_TOTAL > 0)
                .sort((a, b) => b.CHUVA_TOTAL - a.CHUVA_TOTAL)
                .slice(0, 15);
            createBarChart('chart-chuva-total', 'chartTitleChuva', 'chuva', top15Chuva.map(d => d.CHUVA_TOTAL), top15Chuva.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15TempMax = processedData
                .filter(d => d.TEM_MAX !== -Infinity)
                .sort((a, b) => b.TEM_MAX - a.TEM_MAX)
                .slice(0, 15);
            createBarChart('chart-tem-max', 'chartTitleTempMax', 'temp', top15TempMax.map(d => d.TEM_MAX), top15TempMax.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15UmidMax = processedData
                .filter(d => d.UMD_MAX !== -Infinity)
                .sort((a, b) => b.UMD_MAX - a.UMD_MAX)
                .slice(0, 15);
            createBarChart('chart-umd-max', 'chartTitleUmdMax', 'umd', top15UmidMax.map(d => d.UMD_MAX), top15UmidMax.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15VenMax = processedData
                .filter(d => d.VEN_MAX !== -Infinity)
                .sort((a, b) => b.VEN_MAX - a.VEN_MAX)
                .slice(0, 15);
            createBarChart('chart-ven-max', 'chartTitleVenMax', 'vento', top15VenMax.map(d => d.VEN_MAX), top15VenMax.map(d => `${d.DC_NOME} - ${d.UF}`));

            const top15UmidMin = processedData
                .filter(d => d.UMD_MIN !== Infinity)
                .sort((a, b) => a.UMD_MIN - b.UMD_MIN)
                .slice(0, 15);
            createBarChart('chart-umd-min', 'chartTitleUmdMin', 'umd', top15UmidMin.map(d => d.UMD_MIN), top15UmidMin.map(d => `${d.DC_NOME} - ${d.UF}`), false);

            const top15TempMin = processedData
                .filter(d => d.TEM_MIN !== Infinity)
                .sort((a, b) => a.TEM_MIN - b.TEM_MIN)
                .slice(0, 15);
            createBarChart('chart-tem-min', 'chartTitleTempMin', 'temp', top15TempMin.map(d => d.TEM_MIN), top15TempMin.map(d => `${d.DC_NOME} - ${d.UF}`), false);

            addSortableTableFunctionality();
            
            // Fonte de dados (Tradução)
            const dataSourceText = translations[currentLang].sourceText(todayFormatted, yesterdayFormatted);
            DATA_SOURCE_INFO_BOTTOM.textContent = dataSourceText;
            DATA_SOURCE_INFO_TOP.textContent = dataSourceText;

            LOADING_ANIMATION.style.display = 'none';
            DATA_CONTAINER.style.display = 'block';
            DATA_TABLES_CONTAINER.style.display = 'block';
            DATA_SOURCE_INFO_BOTTOM.style.display = 'block';
            DATA_SOURCE_INFO_TOP.style.display = 'block';
        }

        function getCellValue(tr, idx) {
            const cell = tr.children[idx];
            const value = cell.textContent || cell.innerText;
            const parsedValue = parseFloat(value.replace(',', '.'));
            return isNaN(parsedValue) ? value.trim() : parsedValue;
        }

        /**
         * Adiciona funcionalidade de ordenação às tabelas.
         */
        function addSortableTableFunctionality() {
            document.querySelectorAll('th[data-column-index]').forEach(headerCell => {
                // Remove o event listener antigo para evitar duplicação em re-renderizações
                const oldListener = headerCell.onclick;
                if (oldListener) {
                    headerCell.removeEventListener('click', oldListener);
                }
                
                // Novo event listener
                headerCell.addEventListener('click', function sortTable() {
                    const table = headerCell.closest('table');
                    const tbody = table.querySelector('tbody');
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const isSummaryTable = table.id === 'table-summary';

                    const dataRows = rows.filter(row => row.children.length > 1);

                    const column = parseInt(headerCell.dataset.columnIndex);
                    let sortOrder = headerCell.dataset.sortOrder;

                    sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
                    headerCell.dataset.sortOrder = sortOrder;

                    headerCell.closest('tr').querySelectorAll('th').forEach(th => {
                        if (th !== headerCell) {
                            th.dataset.sortOrder = '';
                        }
                    });

                    // Índices de colunas que contêm dados numéricos
                    const numericColumnsSummary = [1, 2, 3, 4, 5, 6];
                    const numericColumnsStations = [2, 3, 4, 5, 6, 7];

                    const isNumeric = isSummaryTable
                        ? numericColumnsSummary.includes(column)
                        : numericColumnsStations.includes(column);

                    dataRows.sort((a, b) => {
                        let valA = getCellValue(a, column);
                        let valB = getCellValue(b, column);

                        if (isNumeric) {
                            valA = typeof valA === 'number' ? valA : (sortOrder === 'asc' ? Infinity : -Infinity);
                            valB = typeof valB === 'number' ? valB : (sortOrder === 'asc' ? Infinity : -Infinity);
                        } else {
                            valA = String(valA);
                            valB = String(valB);
                            // Usar o idioma atual para ordenação de texto
                            const comparison = valA.localeCompare(valB, currentLang);
                            return sortOrder === 'asc' ? comparison : -comparison;
                        }

                        const comparison = valA - valB;
                        return sortOrder === 'asc' ? comparison : -comparison;
                    });

                    tbody.innerHTML = '';
                    dataRows.forEach(row => tbody.appendChild(row));

                    // Reaplicar a linha da capital no topo (se for tabela de UF)
                    if (!isSummaryTable) {
                        const ufTitle = headerCell.closest('div').querySelector('.uf-title');
                        if (ufTitle) {
                            const uf = ufTitle.textContent.trim();
                            const capitalRow = rows.find(row => row.classList.contains('capital-row'));
                            if (capitalRow) {
                                tbody.prepend(capitalRow);
                            }
                        }
                    }
                });
            });
        }

        // Inicialização dos controles do seletor de data (opção 2)
        function initializeDateSelector() {
            const input = document.getElementById('selectedDate');
            const loadButton = document.getElementById('loadDateButton');

            // Definir valor padrão = hoje (formato YYYY-MM-DD)
            const today = new Date();
            input.value = formatDate(today);
            // Limitar max = hoje
            input.max = formatDate(today);

            loadButton.addEventListener('click', () => {
                const val = input.value;
                if (!val) return alert('Escolha uma data válida.');
                // Invalidar cache se data mudou
                if (cachedDateUsed !== val) {
                    cachedProcessedData = null;
                    cachedRegionalSummary = null;
                    cachedDateUsed = null;
                }
                // Carregar a data escolhida (reRender = false para forçar fetch)
                fetchAndProcessData(val, false);
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeDateSelector();
            // Carregar com data padrão (hoje)
            fetchAndProcessData(null, false);
        });
    </script>
</body>
</html>

